beta_hat[i,] <- myglm(data$y ~ data$t, data = data)$coef[,1])
beta_hat[i,] <- myglm(data$y ~ data$t, data = data)$coef[,1]
myglm(data$y~data$t+I(data$t^2) + data$t, data = data)$coef[,1]
beta_hat[i,] <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
beta_hat
myglm(data$y~data$t+I(data$t^2) + data$t, data = data)$coef[,1]
beta_hat <- matrix(0, nrow = 1000, ncol = 3)
for (i in 1:1000){
beta_hat[i,] <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
}
beta_hat
myglm(data$y~data$t+I(data$t^2) + data$t, data = data)$coef[,1]
?var
?var(beta_hat)
# myglm(data$y~data$t+I(data$t^2) + data$t, data = data)$coef[,1]
beta_hat <- matrix(0, nrow = 1000, ncol = 3)
for (i in 1:1000){
beta_hat[i,] <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
}
?var(beta_hat)
var(beta_hat)
# myglm(data$y~data$t+I(data$t^2) + data$t, data = data)$coef[,1]
beta_hat <- matrix(0, nrow = 1000, ncol = 3)
for (i in 1:1000){
beta_hat[i,] <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
}
var(beta_hat)
# myglm(data$y~data$t+I(data$t^2) + data$t, data = data)$coef[,1]
beta <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
X <- model.matrix(y ~ t + I(t^2), data)
lambda <- exp(X*beta)
beta_hat <- matrix(0, nrow = 1000, ncol = 3)
for (i in 1:1000){
y_simulated <- rpois(n=135,lambda)
beta_hat[i,] <- myglm(y_simulated~data$t+I(data$t^2), data = data)$coef[,1]
}
var(beta_hat)
beta_hat
# myglm(data$y~data$t+I(data$t^2) + data$t, data = data)$coef[,1]
beta <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
X <- model.matrix(y ~ t + I(t^2), data)
lambda <- exp(X*beta)
beta_hat <- matrix(0, nrow = 1000, ncol = 3)
for (i in 1:1000){
y_simulated <- rpois(135,lambda)
beta_hat[i,] <- myglm(y_simulated~data$t+I(data$t^2), data = data)$coef[,1]
}
beta_hat
var(beta_hat)
beta <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
X <- model.matrix(y ~ t + I(t^2), data)
lambda <- exp(X*beta)
lambda
beta <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
X <- model.matrix(y ~ t + I(t^2), data)
lambda <- exp(X*beta)
lambda
beta <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
X <- model.matrix(y ~ t + I(t^2), data)
lambda <- exp(X*beta)
lambda
lambda <- exp(X%*%beta)
beta <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
X <- model.matrix(y ~ t + I(t^2), data)
lambda <- exp(X%*%beta)
lambda
beta <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
X <- model.matrix(y ~ t + I(t^2), data)
eta <- as.vector(X%*%beta) #eta vector
lambda <- exp(eta)
lambda
# myglm(data$y~data$t+I(data$t^2) + data$t, data = data)$coef[,1]
beta <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
X <- model.matrix(y ~ t + I(t^2), data)
eta <- as.vector(X%*%beta) #eta vector
lambda <- exp(eta)
beta_hat <- matrix(0, nrow = 1000, ncol = 3)
for (i in 1:1000){
y_simulated <- rpois(135,lambda)
beta_hat[i,] <- myglm(y_simulated~data$t+I(data$t^2), data = data)$coef[,1]
}
beta_hat
var(beta_hat)
X <- model.matrix(formula, data)
formula <- data$y~data$t+I(data$t^2)
beta <- myglm(formula, data = data)$coef[,1]
X <- model.matrix(formula, data)
eta <- as.vector(X%*%beta) #eta vector
lambda <- exp(eta)
beta_hat <- matrix(0, nrow = 1000, ncol = 3)
for (i in 1:1000){
y_simulated <- rpois(135,lambda)
beta_hat[i,] <- myglm(y_simulated~data$t+I(data$t^2), data = data)$coef[,1]
}
beta_hat
var(beta_hat)
y_simulated
formula <- data$y~data$t+I(data$t^2)
beta <- myglm(formula, data = data)$coef[,1]
X <- model.matrix(formula, data)
eta <- as.vector(X%*%beta) #eta vector
lambda <- exp(eta)
beta_hat <- matrix(0, nrow = 1000, ncol = 3)
for (i in 1:1000){
y_simulated <- rpois(135,lambda)
y_simulated
beta_hat[i,] <- glm(ysim ~ t, data = sim_data, family = poisson)$coeff
}
beta_hat[i,] <- glm(ysim ~ t, data = data, family = poisson)$coeff
formula <- data$y~data$t+I(data$t^2)
beta <- myglm(formula, data = data)$coef[,1]
X <- model.matrix(formula, data)
eta <- as.vector(X%*%beta) #eta vector
lambda <- exp(eta)
beta_hat <- matrix(0, nrow = 1000, ncol = 3)
for (i in 1:1000){
data$y <- rpois(135,lambda)
beta_hat[i,] <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
}
beta_hat
var(beta_hat)
# beta_hat
var(beta_hat)
myglm(formula, data = data)$covariance
myglm(formula, data = data)$variance
myglm(formula, data = data)$vcov
formula <- data$y~data$t+I(data$t^2)
beta <- myglm(formula, data = data)$coef[,1]
X <- model.matrix(formula, data)
eta <- as.vector(X%*%beta) #eta vector
lambda <- exp(eta)
beta_hat <- matrix(0, nrow = 1000, ncol = 3)
for (i in 1:1000){
data$y <- rpois(135,lambda)
beta_hat[i,] <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
}
# variance of beta_hat
var(beta_hat)
myglm(formula, data = data)$vcov
mean(data$t)
theta
n <- 135
xbar <- mean(data$t)
#pvalue
pvalue <- 2*(1-pnorm(xbar,mean=theta,sd=sqrt(omega)/sqrt(n)))
```{r bootstrapping evalute=FALSE}
#data from problem 2 (called data)
load(url("https://www.math.ntnu.no/emner/TMA4315/2020h/hoge-veluwe.Rdata"))
formula = data$y~data$t+I(data$t^2)
#myglm function from 1b
mod <- myglm(formula, data)
mod
#glm function
testMod <- glm(formula = formula, family = poisson(link = log))
summary(testMod)
vcov(testMod)
#data from problem 2 (called data)
load(url("https://www.math.ntnu.no/emner/TMA4315/2020h/hoge-veluwe.Rdata"))
formula = data$y~data$t+I(data$t^2)
#myglm function from 1b
mod <- myglm(formula, data)
mod
#glm function
testMod <- glm(formula = formula, family = poisson(link = log))
summary(testMod)
vcov(testMod)
#hypothesis test using LRT, comparing deviances
modA <- mod #with beta2
modB <- myglm(data$y~t, data) #model without beta2
deviancediff <- modB$deviance- mod$deviance
#calculate pvalue
pvalue <- 1-pchisq(deviancediff, 1)
hist(data$y)
hist(data$y, prob=TRUE, ylim = c(0, .25)) # may need to tweak the y axis.
lines(0:max(vec), dpois(0:max(vec), mean(vec)), col = 'red')
hist(data$y, prob=TRUE)
lines(0:max(vec), dpois(0:max(vec), mean(vec)), col = 'red')
hist(data$y, prob=TRUE)
lines(0:max(data$y), dpois(0:max(data$y), mean(data$y)), col = 'red')
hist(data$y, prob=TRUE, title = "Histogram of y")
lines(0:max(data$y), dpois(0:max(data$y), mean(data$y)), col = 'red')
hist(data$y, prob=TRUE, label = "Histogram of y")
lines(0:max(data$y), dpois(0:max(data$y), mean(data$y)), col = 'red')
hist(data$y, prob=TRUE)
lines(0:max(data$y), dpois(0:max(data$y), mean(data$y)), col = 'red')
knitr::opts_chunk$set(echo = TRUE)
# install.packages("knitr") #probably already installed
# install.packages("rmarkdown") #probably already installed
myglm <- function(formula, data, start=0) {
y <- data$y
X <- model.matrix(formula, data) #design matrix
beta <- rep(0, ncol(X)) #beta vector
repeat {
eta <- as.vector(X%*% beta) #eta vector
lambda <- exp(eta)
W <- diag(lambda) #diagonal matrix of lambdas
score <- apply((y-lambda)*X,2,sum)
Fisherinfo <- t(X) %*% W %*% X
if (sum(score^2)<1e-10) #break point
break()
#find coefficient estimate and std.error
beta <- beta + solve(Fisherinfo) %*% score
F.inv <- solve(Fisherinfo)
std.error <- sqrt(diag(F.inv))
#matrix of beta and std.error:
coeff = cbind(beta, std.error)
colnames(coeff) <- c("Estimate", "Std.Error")
}
# find deviance
log.cand <- sum(y*log(lambda)-lambda) #removed y as it cancels!
log.sat <- sum(ifelse(y==0,0,y*log(y) ) - y ) #set y=lambda
deviance = 2 * (log.sat - log.cand)
return (list(coef=coeff, deviance=deviance, vcov = F.inv))
}
#data from problem 2 (called data)
load(url("https://www.math.ntnu.no/emner/TMA4315/2020h/hoge-veluwe.Rdata"))
formula = data$y~data$t+I(data$t^2)
#myglm function from 1b
mod <- myglm(formula, data)
mod
#glm function
testMod <- glm(formula = formula, family = poisson(link = log))
summary(testMod)
vcov(testMod)
mod
#hypothesis test using LRT, comparing deviances
modA <- mod #with beta2
modB <- myglm(data$y~t, data) #model without beta2
deviancediff <- modB$deviance- mod$deviance
#calculate pvalue
pvalue <- 1-pchisq(deviancediff, 1)
#deviance test for model, pvalue
pvalue <- 1 - pchisq(mod$deviance, (length(data$t)-length(mod$coef)) )
pvalue
hist(data$y, prob=TRUE)
lines(0:max(data$y), dpois(0:max(data$y), mean(data$y)), col = 'red')
coeflist <- mod$coef
omega = -1/(2*coeflist[3,1])
omega
theta = -coeflist[2,1]/(2*coeflist[3,1])
theta
n <- 135
xbar <- mean(data$t)
#pvalue
pvalue <- 2*(1-pnorm(xbar,mean=theta,sd=sqrt(omega)/sqrt(n)))
coeflist <- mod$coef
omega = sqrt(-1/(2*coeflist[3,1]))
omega
theta = coeflist[2,1]/(sqrt(-2*coeflist[3,1]))
theta
coeflist <- mod$coef
omega = sqrt(-1/(2*coeflist[3,1]))
omega
theta = coeflist[2,1]/(-2*coeflist[3,1])
theta
coeflist <- mod$coef
beta1 <-coeflist[2,1]
beta2 <-coeflist[3,1]
omega = sqrt(-1/(2*beta2))
theta = beta1/(-2*beta2)
covmatrix <- mod$vcov
covmatrix
varb1
varb1 <-covmatrix[1]
varb1
covmatrix
covmatrix <- mod$vcov
covmatrix
varb1 <-covmatrix[1]
varb1
varb2 <-covmatrix[2,2]
varb2
covmatrix <- mod$vcov
covmatrix
varb1 <-covmatrix[2,2]
varb1
varb2 <-covmatrix[3,3]
varb2
vartheta = (-1/(2*beta2))^2
covb1b2 <- covmatrix[2:3,2:3]
covb1b2
covmatrix <- mod$vcov
varb1 <-covmatrix[2,2]
varb2 <-covmatrix[3,3]
covb1b2 <- covmatrix[2:3,2:3]
covb1b2
vartheta = (-1/(2*beta2))^2
covb1b2 <- covmatrix[2:3,2:3]
covb1b2
covmatrix
knitr::opts_chunk$set(echo = TRUE)
# install.packages("knitr") #probably already installed
# install.packages("rmarkdown") #probably already installed
myglm <- function(formula, data, start=0) {
y <- data$y
X <- model.matrix(formula, data) #design matrix
beta <- rep(0, ncol(X)) #beta vector
repeat {
eta <- as.vector(X%*% beta) #eta vector
lambda <- exp(eta)
W <- diag(lambda) #diagonal matrix of lambdas
score <- apply((y-lambda)*X,2,sum)
Fisherinfo <- t(X) %*% W %*% X
if (sum(score^2)<1e-10) #break point
break()
#find coefficient estimate and std.error
beta <- beta + solve(Fisherinfo) %*% score
F.inv <- solve(Fisherinfo)
std.error <- sqrt(diag(F.inv))
#matrix of beta and std.error:
coeff = cbind(beta, std.error)
colnames(coeff) <- c("Estimate", "Std.Error")
}
# find deviance
log.cand <- sum(y*log(lambda)-lambda) #removed y as it cancels!
log.sat <- sum(ifelse(y==0,0,y*log(y) ) - y ) #set y=lambda
deviance = 2 * (log.sat - log.cand)
return (list(coef=coeff, deviance=deviance, vcov = F.inv))
}
#data from problem 2 (called data)
load(url("https://www.math.ntnu.no/emner/TMA4315/2020h/hoge-veluwe.Rdata"))
formula = data$y~data$t+I(data$t^2)
#myglm function from 1b
mod <- myglm(formula, data)
mod
#glm function
testMod <- glm(formula = formula, family = poisson(link = log))
summary(testMod)
vcov(testMod)
mod
#hypothesis test using LRT, comparing deviances
modA <- mod #with beta2
modB <- myglm(data$y~t, data) #model without beta2
deviancediff <- modB$deviance- mod$deviance
#calculate pvalue
pvalue <- 1-pchisq(deviancediff, 1)
#deviance test for model, pvalue
pvalue <- 1 - pchisq(mod$deviance, (length(data$t)-length(mod$coef)) )
pvalue
hist(data$y, prob=TRUE)
lines(0:max(data$y), dpois(0:max(data$y), mean(data$y)), col = 'red')
coeflist <- mod$coef
beta1 <-coeflist[2,1]
beta2 <-coeflist[3,1]
omega = sqrt(-1/(2*beta2))
theta = beta1/(-2*beta2)
covmatrix <- mod$vcov
varb1 <-covmatrix[2,2]
varb2 <-covmatrix[3,3]
covb1b2 <- covmatrix[2:3,2:3]
vartheta = (-1/(2*beta2))^2*varb1 + (beta1/(4*beta2^2))^2*varb2 + 2(-beta1/(8*beta2^3))*covb1b2
covmatrix <- mod$vcov
varb1 <-covmatrix[2,2]
varb2 <-covmatrix[3,3]
covb1b2 <- covmatrix[2:3,2:3]
vartheta = (-1/(2*beta2))^2*varb1 + (beta1/(4*beta2^2))^2*varb2 + 2(-beta1/(8*beta2^3))%*%covb1b2
covmatrix <- mod$vcov
varb1 <-covmatrix[2,2]
varb2 <-covmatrix[3,3]
covb1b2 <- covmatrix[2:3,2:3]
vartheta = (-1/(2*beta2))^2*varb1 + (beta1/(4*beta2^2))^2*varb2 + 2*(-beta1/(8*beta2^3))%*%covb1b2
covmatrix <- mod$vcov
varb1 <-covmatrix[2,2]
varb2 <-covmatrix[3,3]
covb1b2 <- covmatrix[2:3,2:3]
vartheta = (-1/(2*beta2))^2*varb1 + (beta1/(4*beta2^2))^2*varb2 + 2*(-beta1/(8*beta2^3))*covb1b2
vartheta
covmatrix <- mod$vcov
varb1 <-covmatrix[2,2]
varb2 <-covmatrix[3,3]
covb1b2 <- covmatrix[2:3,2:3]
vartheta = (-1/(2*beta2))^2*varb1 + (beta1/(4*beta2^2))^2*varb2 + 2*(-beta1/(8*beta2^3))*covb1b2
vartheta
covmatrix <- mod$vcov
varb1 <-covmatrix[2,2]
varb2 <-covmatrix[3,3]
covb1b2 <- covmatrix[2:3,2:3]
vartheta = (-1/(2*beta2))^2*varb1 + (beta1/(4*beta2^2))^2*varb2 + 2*(-beta1/(8*beta2^3))*covb1b2
vartheta
#set up
beta <- myglm(formula, data = data)$coef[,1]
X <- model.matrix(formula, data)
eta <- as.vector(X%*%beta) #eta vector
lambda <- exp(eta)
#matrix of estimated betahat from each bootstrap sample
beta_hat <- matrix(0, nrow = 1000, ncol = 3)
#bootstrapping
for (i in 1:1000){
data$y <- rpois(135,lambda) #new estimate of y from a poisson distribution
beta_hat[i,] <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
}
# variance of beta_hat
var(beta_hat)
myglm(formula, data = data)$vcov
#set up
beta <- myglm(formula, data = data)$coef[,1]
X <- model.matrix(formula, data)
eta <- as.vector(X%*%beta) #eta vector
lambda <- exp(eta)
#matrix of estimated betahat from each bootstrap sample
beta_hat <- matrix(0, nrow = 1000, ncol = 3)
#bootstrapping
for (i in 1:1000){
data$y <- rpois(135,lambda) #new estimate of y from a poisson distribution
beta_hat[i,] <- myglm(data$y~data$t+I(data$t^2), data = data)$coef[,1]
}
# variance of beta_hat
var(beta_hat)
#covariance matrix from fitted model in problem 2
mod$vcov
covmatris
covb1b2
#find variances and covariances of beta vector
covmatrix <- mod$vcov
varb1 <-covmatrix[2,2]
varb2 <-covmatrix[3,3]
covb1b2 <- covmatrix[2:3,2:3]
covb1b2
#gradients for g and h
grad_g <- c(0, (-1/(2*beta2))^(3/2) )
grad_h <- c(-1/(2*beta2), (beta1/(2*beta2^2))^2 )
sd_omega <- sqrt(t(grad_g) %*% covb1b2 %*% grad_g)
sd_theta <- sqrt(t(grad_h) %*% covb1b2 %*% grad_h)
sd_theta
sd_omega
grad_h <- c(-1/(2*beta2), (beta1/(2*beta2^2)) )
n <- 135
xbar <- mean(data$t)
#pvalue
pvalue <- 2*(1-pnorm(xbar,mean=theta,sd=sqrt(omega)/sqrt(n)))
pvalue
theta
n <- 135
xbar <- mean(data$t)
#pvalue
pvalue <- 2*(1-pnorm(xbar,mean=theta,sd=sqrt(omega)/sqrt(n)))
pvalue
xbar
omega
pnorm(xbar,mean=theta,sd=sqrt(omega)/sqrt(n))
xbar
theta
n <- 135
xbar <- mean(data$t)
pnorm(xbar,mean=theta,sd=sqrt(omega)/sqrt(n))
#pvalue
pvalue <- 2*(1-pnorm(xbar,mean=theta,sd=sqrt(omega)/sqrt(n)))
pvalue
n <- 135
xbar <- mean(data$t)
xbar
theta
pnorm(xbar,mean=theta,sd=sqrt(omega)/sqrt(n))
#pvalue
pvalue <- 2*(1-pnorm(xbar,mean=theta,sd=sqrt(omega)/sqrt(n)))
pvalue
Z
Z <- xbar-theta/(sqrt(omega)/sqrt(n))
Z
-2pnorm(-abs(Z))
-2*pnorm(-abs(Z))
n <- 135
xbar <- mean(data$t)
xbar
theta
pnorm(xbar,mean=theta,sd=sqrt(omega)/sqrt(n))
Z <- xbar-theta/(sqrt(omega)/sqrt(n))
-2*pnorm(-abs(Z))
pvalue
Z <- xbar-theta/(omega/sqrt(n))
pvalue <- 2*pnorm(-abs(Z))
#pvalue
pvalue <- 2*(1-pnorm(xbar,mean=theta,sd=sqrt(omega)/sqrt(n)))
pvalue
n <- 135
xbar <- mean(data$t)
xbar
theta
#pnorm(xbar,mean=theta,sd=sqrt(omega)/sqrt(n))
Z <- xbar-theta/(omega/sqrt(n))
pvalue <- 2*pnorm(-abs(Z))
pvalue
#pvalue
pvalue <- 2*(1-pnorm(xbar,mean=theta,sd=sqrt(omega)/sqrt(n)))
pvalue
n <- 135
tbar <- mean(data$t)
Z <- tbar-theta/(omega/sqrt(n))
pvalue <- 2*pnorm(-abs(Z))
pvalue
n <- 135
tbar <- mean(data$t)
Z <- tbar-theta/(omega/sqrt(n))
pvalue <- 2*pnorm(-abs(Z))
pvalue
# install.packages("knitr") #probably already installed
# install.packages("rmarkdown") #probably already installed
install.packages('tinytex')
install.packages("tinytex")
library(knitr)
library(rmarkdown)
opts_chunk$set(tidy.opts=list(width.cutoff=68),tidy=TRUE)
knitr::opts_chunk$set(echo = TRUE,tidy=TRUE,message=FALSE,warning=FALSE,strip.white=TRUE,prompt=FALSE,
cache=TRUE, size="scriptsize")
# install.packages("knitr")
# install.packages("rmarkdown")
# install.packages('tinytex')
tinytex:::install_prebuilt()
# install.packages("knitr")
# install.packages("rmarkdown")
# install.packages('tinytex')
tinytex:::install_prebuilt()
