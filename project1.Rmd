---
subtitle: "TMA4315 GLM H2020"
title: "Project 1"
author: "Silje Anfindsen"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
 # html_document
 pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r rpackages,eval=TRUE,echo=FALSE}
# install.packages("knitr") #probably already installed
# install.packages("rmarkdown") #probably already installed
# install.packages("ggplot2") #plotting with ggplot

```

# Problem 1

##1a) 

##1b) Fisher Scoring Algorithm

The expected Fisher information matrix $F$ needs to be invertible. As the parameters $\lambda_i=e^{x_i^T\beta}>0$ for all $i$ and the design matrix $X$ has full rank, $p$ we know $F$ is invertible. With the linear link $\lambda_i = \eta_i$ we set some restrictions:


Standard error estimates are the the square root of diagonal elements of of the inverse Fisher information matrix


for the observation $y_i=0$ and $\hat{\lambda}=y_i=0$ (saturated model)...

```{r myglm, eval=TRUE, echo=TRUE}

#input: model formula, data frame, start point
#output: coefficients, deviance, estimated variance of coefficients
myglm <- function(formula, data, start=0) {
  y <- data$y
  X <- model.matrix(formula, data) #design matrix
  beta <- rep(0, ncol(X)) #beta vector
  
  repeat {
    eta <- as.vector(X%*% beta) #eta vector
    lambda <- exp(eta) 
    W <- diag(lambda) #diagonal matrix of lambdas
    score <- apply((y-lambda)*X,2,sum)
    Fisherinfo <- t(X) %*% W %*% X
    
  if (sum(score^2)<1e-10) #break point
    break()
    
    #find coefficient estimate and std.error
    beta <- beta + solve(Fisherinfo) %*% score
    F.inv <- solve(Fisherinfo)
    std.error <- sqrt(diag(F.inv))
    #matrix of beta and std.error:
    coeff = cbind(beta, std.error)
    colnames(coeff) <- c("Estimate", "Std.Error")
  }
  # find deviance
  log.cand <- sum(as.vector(y*log(lambda)-lambda)) #removed y as it cancels!
  yfix <- y #fix special case for saturated model when lambda=y=0
  yfix[y==0] <- 1 #set log(0)=1
  log.sat <- sum(as.vector(yfix * log(yfix)-yfix)) #set y=lambda
  deviance = 2 * sum(log.sat - log.cand)
  # cat(deviance,"\n")
  
  return (list(coefficients=coeff, deviance=deviance, vcov = F.inv))
  
 }
  
```


## 1c)
```{r test myglm}

#model from ex.2
load(url("https://www.math.ntnu.no/emner/TMA4315/2020h/hoge-veluwe.Rdata"))
mod <- myglm(data$y~., data)
mod

#test code with glm function
testMod <- glm(formula = data$y~., data = data, family = poisson(link = log))
summary(testMod)
vcov(testMod)


```





